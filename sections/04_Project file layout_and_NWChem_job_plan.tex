
\section{Project file layout and NWChem job plan}
\label{sec:files}

\paragraph{Goals.}
(i) Minimize directory depth and enable a single parsing loop across outputs;
(ii) harvest \textbf{HF} and \textbf{MP2} energies from each \textbf{CCSD(T)} run to avoid redundant jobs;
(iii) keep runs fully reproducible and easy to re-generate.

\paragraph{Shallow, one-geometry-one-output (OGOO) layout.}
All geometry-specific work lives under
\texttt{\textless molecule\textgreater/\textless basis\textgreater/\textless shape\textgreater/s\textless 3-digit scale\textgreater/}:
\begin{verbatim}
<MOL>/<BASIS>/<SHAPE>/s001/
  run.nw     # all fragments + ghosts + all methods (SCF, MP2, CCSD(T))
  run.out    # single output to parse
  terms.csv  # aggregated row per geometry (energies + CP/BSSE)
\end{verbatim}
Here \texttt{<BASIS>} $\in$ \{\texttt{AVDZ}, \texttt{AVTZ}, \texttt{AVQZ}\}, and \texttt{<SHAPE>} encodes the trimer geometry family.
The directory name for the scale keeps your original convention \texttt{shape/s001}.

\paragraph{Monomer cache (geometry independent).}
Compute $E_A(A)$, $E_B(B)$, $E_C(C)$ once per basis and reuse:
\begin{verbatim}
<MOL>/cache/monomers/<BASIS>/
  monomers.nw   monomers.out   monomers.json
\end{verbatim}
This avoids repeating the same isolated-monomer optimizations for every geometry/scale.

\paragraph{Single-input strategy with method harvesting.}
For a given geometry, \texttt{run.nw} contains all fragment/basis-with-ghost tasks needed for CP on a trimer. Each task group is labeled with a unique \texttt{title} so parsers can grep reliably.
Each block runs, in order,
\begin{verbatim}
task scf
task mp2
task ccsd(t)
\end{verbatim}
so that \texttt{run.out} \emph{always} contains HF, MP2, and CCSD(T) energies for the same geometry and fragment/basis.
No per-method folders are needed; a single pass over \texttt{run.out} can collect all three methods.

\paragraph{Which energies are evaluated per geometry.}
If monomer self-energies are re-used from the cache, we evaluate $15$ geometry-specific terms per basis; if recomputed each time, there are $18$:
\begin{align*}
&\text{Monomers (cache or per-geometry): } E_A(A),\,E_B(B),\,E_C(C) \\
&\text{Monomers in ghosts: }
  E_A(AB),\,E_A(AC),\,E_A(ABC),\;
  E_B(AB),\,E_B(BC),\,E_B(ABC),\;
  E_C(AC),\,E_C(BC),\,E_C(ABC) \\
&\text{Dimers in their own basis: } E_{AB}(AB),\,E_{AC}(AC),\,E_{BC}(BC) \\
&\text{Dimers in trimer basis: } E_{AB}(ABC),\,E_{AC}(ABC),\,E_{BC}(ABC) \\
&\text{(Optional) Trimer: } E_{ABC}(ABC).
\end{align*}
Each quantity is captured for the three methods (SCF, MP2, CCSD(T)) from the \emph{same} output file.

\paragraph{Recommended file tags and parse keys.}
Prepend each block with a unique \texttt{title}, e.g.,
\texttt{title "E\_A(AB) : <MOL> <BASIS> <SHAPE> s001"},
so \texttt{terms.csv} can be populated by a single sweep over \texttt{run.out} using the tuple
\((\text{label}, \text{method})\) where \(\text{method} \in \{\text{SCF}, \text{MP2}, \text{CCSD(T)}\}\).
We standardize labels as strings like \texttt{E\_A(AB)}, \texttt{E\_AB(ABC)}, etc.

\paragraph{Minimal \texttt{run.nw} skeleton (per geometry).}
Below shows the pattern; repeat for each required fragment/basis-with-ghosts.
The \texttt{title} lines are the key to painless parsing.
\begin{verbatim}
start trimer_example
set print high
memory total 4000 mb

# --- Geometry with labeled fragments A, B, C ---
geometry units angstrom noautoz
  fragment A
    ...  # atoms of monomer A
  fragment B
    ...  # atoms of monomer B
  fragment C
    ...  # atoms of monomer C
end

# --- Basis blocks you'll switch between (AB, AC, BC, ABC) ---
basis "AB" spherical
  # define basis on A & B; use 'ghost' for centers not active
end

# ------------ E_A(AB): monomer A in AB basis (B as ghost) ------------
title "E_A(AB) : <MOL> <BASIS> <SHAPE> s001"
set geometry:fragment A
task scf
task mp2
task ccsd(t)

# ------------ E_AB(AB): dimer AB in AB basis ------------
title "E_AB(AB) : <MOL> <BASIS> <SHAPE> s001"
set geometry:fragment AB
task scf
task mp2
task ccsd(t)

# ------------ E_AB(ABC): dimer AB in ABC basis ------------
title "E_AB(ABC) : <MOL> <BASIS> <SHAPE> s001"
# define ABC basis (basis on all centers; ghost C for dimer AB if appropriate)
task scf
task mp2
task ccsd(t)

# ... repeat other required blocks ...
\end{verbatim}

\paragraph{Parser/CSV convention (single-loop friendly).}
\begin{itemize}[leftmargin=2em]
  \item \textbf{Key} each energy by \verb|(label, method)| where
        \verb|label \in {"E_A(AB)", "E_AB(ABC)", ...}| and
        \verb|method \in {"SCF","MP2","CCSD(T)"}|.
  \item \textbf{Row schema} for \texttt{terms.csv} (per geometry):\\
  \texttt{mol,basis,shape,scale, E\_A(A)\_SCF, E\_A(A)\_MP2, E\_A(A)\_CCSDT, ..., E\_AB(ABC)\_CCSDT, E\_ABC(ABC)\_CCSDT, CP\_interaction(method), BSSE(method)}
  \item \textbf{Reuse} the cached $E_A(A)$, $E_B(B)$, $E_C(C)$ columns by basis from\\
        \texttt{<molecule>/cache/monomers/<basis>/monomers.json}.
\end{itemize}

\paragraph{Automation hook.}
Alongside \texttt{run.nw}, store \texttt{geom.json} with Cartesian coordinates and the scale tag (e.g., \texttt{s001}).
A Python driver:
(i) builds \texttt{run.nw} from \texttt{geom.json} and a template,
(ii) executes NWChem,
(iii) parses HF/MP2/CCSD(T) energies keyed by \texttt{title} lines,
(iv) computes CP-corrected interaction energies and BSSE per method, and
(v) appends a row to \texttt{terms.csv}.
This preserves your original workflow while enabling a single over-the-tree parsing loop.
